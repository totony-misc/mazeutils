/*
 * @name Terrain kill
 * @author Totony#1224
 * @desc
 *   This is a terrain kill trigger, which allows certain terrain types to kill units automatically.
 *   Variables needed:
 *   - udg_tt_killterrain - terrain type that kills
 *   - udg_r_killterrain_granularity - offset (0 < x < 64), allows flexibility in how far one can go into killable terrain
 *   - udg_ug_dh - unit group for which this trigger applies
 * @note Will probably change a lot (even variable names)
 */

// Returns true if terrain at (x,y) is terrainType
function T_Checker_TerrainComp takes integer terrainType, real x, real y returns boolean
	local location loc = Location(x, y)
	local integer terrainTypeAtPos = GetTerrainTypeBJ(loc)

	call RemoveLocation(loc)
	set loc = null

	return terrainTypeAtPos == terrainType
endfunction


// Returns true if the unit is surronded by terrainType (in a diagonal setting)
// This relaxes the horizontal/vertical terrain detection as it smoothes out the terrain between 2 diagonal tiles
//
// 128 is the smallest tile size, 64 is half of that
// Tiles are centered on (128x, 128y)
//
// (0,0) is top left (cartesian coords are inverted for y)
//
// We have 4 type of diagonals:
//   - Upward (top)      - Diagonal goes downward, but is the top one
//   - Upward (down)     - ...
//   - Downward (top)    - ...
//   - Downward (bottom) - ...
//                      ----\
//                      |  | \    <-- downward (top)
//                      ----  \
//                      \   ----
// downward (bottom) --> \  |  |
//                        \ ----
//
//                        / ----
// upward (top)      --> /  |  |
//                      /   ----
//                      ----  /
//                      |  | /   <--- upward (bot)
//                      ----/
//
// You are safe if (where x and y are your relative position w/r to top left of the empty block):
//   - Upward   (top): y >= 128 - x
//   - Upward   (bot): y <= 128 - x
//   - Downward (top): y >= x
//   - Downward (bot): y <= x
function T_Checker_D takes integer terrainType, real x, real y returns boolean
	local real rel_x = ModuloReal(x - 64, 128)
	local real rel_y = ModuloReal(y - 64, 128)

	// Terrain above/below/right/left is not killer
	local boolean t_above = not T_Checker_TerrainComp(terrainType, x, y - 128)
	local boolean t_below = not T_Checker_TerrainComp(terrainType, x, y + 128)
	local boolean t_left  = not T_Checker_TerrainComp(terrainType, x - 128, y)
	local boolean t_right = not T_Checker_TerrainComp(terrainType, x + 128, y)

	local boolean down_top = t_below and t_left
	local boolean down_bot = t_above and t_right
	local boolean up_top   = t_below and t_right
	local boolean up_bot   = t_above and t_left

	if (down_bot and rel_y <= rel_x) then
		return false
	endif

	if (down_top and rel_y >= rel_x) then
		return false
	endif

	if (up_top and rel_y >= 128 - rel_x) then
		return false
	endif

	if (up_bot and rel_y <= 128 - rel_x) then
		return false
	endif

	return true
endfunction

// Checks if hero should die
// udg_r_killterrain_granularity should be < 64
// and represents the number of units the DH is allowed to go into terrain
function TK_Checker takes unit u, integer killTerrainType, real granularity returns boolean
	local real x = GetUnitX(u)
	local real y = GetUnitY(u)

	local real angle = 45

	if granularity == 0 then
		set angle = 360
	endif
	
	// Check top/bottom/left/right of circle around unit
	// This is very strict for diagonals
	// u can also check if currently on terrain and calculate the relativeX/Y and compare against granularity
	loop
		exitwhen angle > 360
		// If there is safe terrain somewhere around unit, it shouldn't die
		if not T_Checker_TerrainComp(killTerrainType, x + granularity * Sin(angle * bj_DEGTORAD), y + granularity * Cos(angle * bj_DEGTORAD)) then
			return false
		endif
		set angle = angle + 45
	endloop

	// Check if in a diagonal
	set angle = 45

	if granularity == 0 then
		set angle = 360
	endif

	loop
		exitwhen angle > 360
		// If there is safe diagonal terrain somewhere around unit, it shouldn't die
		if not T_Checker_D(killTerrainType, x + granularity * Sin(angle * bj_DEGTORAD), y + granularity * Cos(angle * bj_DEGTORAD)) then
			return false
		endif
		set angle = angle + 90
	endloop

	// If there is nothing saving the unit, it should die
	return true
endfunction

// @uses integer udg_tt_killterrain
// @uses real udg_r_killterrain_granularity
function TK_Iterator takes nothing returns nothing
	local unit u = GetEnumUnit()

	if ( TK_Checker(u, udg_tt_killterrain, udg_r_killterrain_granularity) ) then
		// we do not need to destroy force since its a built in
		call DisplayTimedTextToForce( GetPlayersAll(), 1.00, "dead" )
	endif

	// Prevent leak
	set u = null
endfunction

// @uses unitgroup udg_ug_dh
function Trig_Terrain_kill_Copy_Copy_Actions takes nothing returns nothing
	call ForGroupBJ( udg_ug_dh, function TK_Iterator )
endfunction

//===========================================================================
function InitTrig_Terrain_kill_Copy_Copy takes nothing returns nothing
	set gg_trg_Terrain_kill_Copy_Copy = CreateTrigger()
	call TriggerRegisterTimerEventPeriodic( gg_trg_Terrain_kill_Copy_Copy, 0.10 )
	call TriggerAddAction( gg_trg_Terrain_kill_Copy_Copy, function Trig_Terrain_kill_Copy_Copy_Actions )
endfunction
