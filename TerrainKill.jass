/*
 * @name Terrain kill
 * @author Totony#1224
 * @desc
 *   This is a terrain kill trigger, which allows certain terrain types to kill units automatically.
 *   Variables needed:
 *   - udg_tt_killterrain - terrain type that kills
 *   - udg_r_killterrain_granularity - offset (0 <= x < 64), allows flexibility in how far one can go into killable terrain
 *   - udg_ug_dh - unit group for which this trigger applies
 * @note Will probably change a lot (even variable names)
 */

// Returns true if terrain at (x,y) is terrainType
function T_Checker_TerrainComp takes integer terrainType, real x, real y returns boolean
	local location loc = Location(x, y)
	local integer terrainTypeAtPos = GetTerrainTypeBJ(loc)

	call RemoveLocation(loc)
	set loc = null

	return terrainTypeAtPos == terrainType
endfunction


// Returns true if the unit is not in the diagonal of terrainType
// This relaxes the horizontal/vertical terrain detection as it smoothes out the terrain between 2 diagonal tiles
//
// 128 is the smallest tile size, 64 is half of that
// Tiles are centered on (128x, 128y)
//
// Map (0,0) is middle, but is a normal cartesian plan (upward +y, rightward +x)
//
// We have 4 type of diagonals:
//   - Upward (top)      - Diagonal goes downward, but is the top one
//   - Upward (down)     - ...
//   - Downward (top)    - ...
//   - Downward (bottom) - ...
//                      ----\
//                      |  | \    <-- downward (top)
//                      ----  \
//                      \   ----
// downward (bottom) --> \  |  |
//                        \ ----
//                     (0,0)
//                        / ----
// upward (top)      --> /  |  |
//                      /   ----
//                      ----  /
//                      |  | /   <--- upward (bot)
//                      ----/
//                     (0,0)
// You are safe if (where x and y are your relative position w/r to top left of the empty block):
//   - Upward   (top): y <= x
//   - Upward   (bot): y >= x
//   - Downward (top): y <= 128 - x
//   - Downward (bot): y >= 128 - x
function T_Checker_TerrainComp_D takes integer terrainType, real x, real y returns boolean
	local real rel_x = ModuloReal(x - 64, 128)
	local real rel_y = ModuloReal(y - 64, 128)

	// Terrain above/below/right/left is not killer
	local boolean t_above = not T_Checker_TerrainComp(terrainType, x, y + 128)
	local boolean t_below = not T_Checker_TerrainComp(terrainType, x, y - 128)
	local boolean t_left  = not T_Checker_TerrainComp(terrainType, x - 128, y)
	local boolean t_right = not T_Checker_TerrainComp(terrainType, x + 128, y)

	local boolean down_top = t_below and t_left
	local boolean down_bot = t_above and t_right
	local boolean up_top   = t_below and t_right
	local boolean up_bot   = t_above and t_left

	if (down_bot and rel_y >= 128 - rel_x) then
		return true
	endif

	if (down_top and rel_y <= 128 - rel_x) then
		return true
	endif

	if (up_top and rel_y <= rel_x) then
		return true
	endif

	if (up_bot and rel_y >= rel_x) then
		return true
	endif

	return false
endfunction

// Returns true if unit is on tile terrainType (accounting for granularity).
// @arg boolean all:
//   if true, unit must be fully on terrainType
//   if false, unit must be partially on terrainType
// @arg real absGranularity:
//   absolute offset to use
function T_Checker takes boolean diagonal, integer terrainType, boolean all, real absGranularity, real x, real y returns boolean
	local boolean onTerrain

	local real angle = 45
	local real angleIncrement = 45

	local real adjX
	local real adjY

	if absGranularity == 0 then
		set angle = 360
	endif

	loop
		exitwhen angle > 360
		set adjX = x + absGranularity * Cos(angle * bj_DEGTORAD)
		set adjY = y + absGranularity * Sin(angle * bj_DEGTORAD)
		
		// TODO: You only need to check for diagonal if angle mod 45 = 0 != mod 90?
		set onTerrain = T_Checker_TerrainComp(terrainType, adjX, adjY) and not (diagonal and T_Checker_TerrainComp_D(terrainType, adjX, adjY))

		if all and not onTerrain then
			return false
		elseif not all and onTerrain then
			return true
		endif
		set angle = angle + angleIncrement
	endloop

	return all
endfunction

// Checks if hero should die
// -64 < granularity < 64
// and represents the number of units the DH is allowed to go into terrain
function TK_Checker takes unit u, integer killTerrainType, real granularity returns boolean
	local real x = GetUnitX(u)
	local real y = GetUnitY(u)

	local boolean relax = granularity > 0

	// Check if unit is on killTerrainType (horizontal/vertical and diagonal)
	// Diagonal must be checked at the same time as horizontal, since it is a OR rule
	// Unit only dies if both horizontal/vertical and diagonal handlers say it dies
	return T_Checker(true, killTerrainType, relax, RAbsBJ(granularity), x, y)
endfunction

// @uses integer udg_tt_killterrain
// @uses real udg_r_killterrain_granularity
function TK_Iterator takes nothing returns nothing
	local unit u = GetEnumUnit()

	if ( TK_Checker(u, udg_tt_killterrain, udg_r_killterrain_granularity) ) then
		// we do not need to destroy force since its a built in
		call DisplayTimedTextToForce( GetPlayersAll(), 1.00, "dead" )
	endif

	// Prevent leak
	set u = null
endfunction

// @uses unitgroup udg_ug_dh
function Trig_Terrain_kill_Copy_Copy_Actions takes nothing returns nothing
	call ForGroupBJ( udg_ug_dh, function TK_Iterator )
endfunction

//===========================================================================
function InitTrig_Terrain_kill_Copy_Copy takes nothing returns nothing
	set gg_trg_Terrain_kill_Copy_Copy = CreateTrigger()
	call TriggerRegisterTimerEventPeriodic( gg_trg_Terrain_kill_Copy_Copy, 0.10 )
	call TriggerAddAction( gg_trg_Terrain_kill_Copy_Copy, function Trig_Terrain_kill_Copy_Copy_Actions )
endfunction
