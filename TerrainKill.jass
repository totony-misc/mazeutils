/*
 * @name Terrain kill
 * @author Totony#1224
 * @desc
 *   This is a terrain kill trigger, which allows certain terrain types to kill units automatically.
 *   Variables needed:
 *   - udg_tt_killterrain - terrain type that kills
 *   - udg_r_killterrain_granularity - offset (0 <= x < 64), allows flexibility in how far one can go into killable terrain
 *   - udg_ug_dh - unit group for which this trigger applies
 * @note Will probably change a lot (even variable names)
 */

// Get the terrain type that's at (x,y), adjusted to account for wacky graphics
// e.g., most  tiles are like this in a square
// y <= x + 128 - b    -----   y <= 256 - b - x
//                     |/ \|
//                   b |\ /|
// y >= b - x          -----   y >= x - 128 + b
//                      b
//
// b = 64
//
// Returns 0 if we cannot guess which tile is at point (x,y)
// Rely on diagonal interpolation, to figure out what to do next
function getTileAt takes real x, real y returns integer
	local real relX = ModuloReal(x - 64, 128)
	local real relY = ModuloReal(y - 64, 128)
	local integer terrainType      = GetTerrainType(x, y)
	
	local integer terrainTypeLeft  = GetTerrainType(x - 128, y)
	local integer terrainTypeRight = GetTerrainType(x + 128, y)
	local integer terrainTypeTop   = GetTerrainType(x, y + 128)
	local integer terrainTypeBot   = GetTerrainType(x, y - 128)

	// Check tile bounds (if single tile)
	if relY > x + 64 then // top left
		// If horizontal/vertical interpolation
		if terrainTypeLeft == terrainType or terrainTypeTop == terrainType then
			return terrainType
		endif
	elseif relY > 192 - x then // top right
		if terrainTypeRight == terrainType or terrainTypeTop == terrainType then
			return terrainType
		endif
	elseif relY < 64 - x then // bottom left
		if terrainTypeLeft == terrainType or terrainTypeBot == terrainType then
			return terrainType
		endif
	elseif relY < x - 64 then // bottom right
		if terrainTypeRight == terrainType or terrainTypeBot == terrainType then
			return terrainType
		endif
	else
		return terrainType
	endif

	// If we are in at a point which is neither interpolated vertically/horizontally, nor is inside the bounds,
	// then it is either interpolated diagonally (other function) or the point is in the diagonal of 2 different tiles,
	// which makes guessing the one displayed very hard since some tiles have priorities over others
	return 0
endfunction


// Returns the tile at (x,y), or 0 if not on the diagonal of 2 identical tiles
// The graphical display might still be a diagonal for some combinations of 2 different tiles,
// but this is not handled and will return 0
function getDiagonalTileAt takes real x, real y returns integer
	local integer tile
	local real A
	local real B

	local real relX = ModuloReal(x - 64, 128)
	local real relY = ModuloReal(y - 64, 128)

	// Downward diagonals
	set A = (128 + relX - relY)/2
	set B = 128 - A
	
	set tile = getTileAt(x - A, y + A)
	if tile == getTileAt(x + B, y - B) then
		return tile
	endif

	// Upward diagonals
	set A = (relX + relY)/2
	set B = 128 - A

	set tile = getTileAt(x - A, y - A)
	if tile == getTileAt(x + B, y + B) then
		return tile
	endif

	return 0
endfunction

function isTileAt takes real x, real y, integer terrainType returns boolean
	return getTileAt(x, y) == terrainType or getDiagonalTileAt(x, y) == terrainType
endfunction

// Returns true if unit is on tile terrainType (accounting for granularity).
// @arg boolean all:
//   if true, unit must be fully on terrainType
//   if false, unit must be partially on terrainType
// @arg real absGranularity:
//   absolute offset to use
function isTileAtWithGranularity takes real x, real y, integer terrainType, boolean all, real absGranularity returns boolean
	local boolean onTerrain

	local real angle = 45
	local real angleIncrement = 45

	local real adjX
	local real adjY

	if absGranularity == 0 then
		set angle = 360
	endif

	loop
		exitwhen angle > 360
		set adjX = x + absGranularity * Cos(angle * bj_DEGTORAD)
		set adjY = y + absGranularity * Sin(angle * bj_DEGTORAD)
		
		// TODO: You only need to check for diagonal if angle mod 45 = 0 != mod 90?
		set onTerrain = isTileAt(adjX, adjY, terrainType)

		if all and not onTerrain then
			return false
		elseif not all and onTerrain then
			return true
		endif
		set angle = angle + angleIncrement
	endloop

	return all
endfunction

// Checks if hero should die
// -64 < granularity < 64
// and represents the number of units the DH is allowed to go into terrain
function TK_Checker takes unit u, integer killTerrainType, real granularity returns boolean
	local real x = GetUnitX(u)
	local real y = GetUnitY(u)

	local boolean relax = granularity > 0

	// Check if unit is on killTerrainType (horizontal/vertical and diagonal)
	// Diagonal must be checked at the same time as horizontal, since it is a OR rule
	return isTileAtWithGranularity(x, y, killTerrainType, true, RAbsBJ(granularity))
endfunction

// @uses integer udg_tt_killterrain
// @uses real udg_r_killterrain_granularity
function TK_Iterator takes nothing returns nothing
	if ( TK_Checker(GetEnumUnit(), udg_tt_killterrain, udg_r_killterrain_granularity) ) then
		// we do not need to destroy force since its a built in
		call DisplayTimedTextToForce( GetPlayersAll(), 1.00, "dead" )
	endif
endfunction

// @uses unitgroup udg_ug_dh
function Trig_Terrain_kill_Copy_Copy_Actions takes nothing returns nothing
	call ForGroup( udg_ug_dh, function TK_Iterator )
endfunction

//===========================================================================
function InitTrig_Terrain_kill_Copy_Copy takes nothing returns nothing
	set gg_trg_Terrain_kill_Copy_Copy = CreateTrigger()
	call TriggerRegisterTimerEventPeriodic( gg_trg_Terrain_kill_Copy_Copy, 0.10 )
	call TriggerAddAction( gg_trg_Terrain_kill_Copy_Copy, function Trig_Terrain_kill_Copy_Copy_Actions )
endfunction
